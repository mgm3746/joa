error.g1.ignored.parallel=The JVM is not using the G1 collector specified in the JVM options and using the parallel collector instead.
error.gc.ignored=The JVM is not using the GC collector specified in the JVM options.
error.parallel.gc.threads.1=A multi-threaded garbage collector is restricted to a single thread with -XX:ParallelGCThreads=1. Multi-threaded garbage collectors require multiple CPUs to work efficiently. The serial collector is more appropriate for single cpu environments.
error.remote.debugging.enabled=Remote debugging is enabled (e.g. -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n or -Xrunjdwp:transport=dt_socket,server=y,address=8787,suspend=n). This is for debugging in lower environments and should not be enabled in production due to performance, security, and stability concerns.
info.64.client=The -client flag no longer serves a purpose in 64-bit JDK8+ and can be removed. Only the server JIT compiler is included in 64-bit JDKs.
info.64.d64.redundant=The -d64 flag does not serve a purpose in JDK8 and is removed in JDK11. It can be removed, as only the server JIT compiler is included in 64-bit JDKs.
info.64.server.redundant=The -server flag no longer serves a purpose in JDK8+ and can be removed, as only the server JIT compiler is included in 64-bit JDKs.
info.ci.compiler.count=The number of compiler threads is set with -XX:CICompilerCount=N. Unless multiple JVMs and/or processes are collocated and competing for resources, it's generally best to remove this option and let JVM determine an appropriate setting (JDK8) or manage it dynamically with ergonomics (JDK11+).
info.cms.disabled=The CMS collector is disabled with -XX:-UseParNewGC -XX:-UseConcMarkSweepGC (JDK8) or -XX:-UseConcMarkSweepGC (JDK8/11), resulting in the default collector being used. Remove the option(s) if the intent is to use the default collector. Replace the option(s) with -XX:+UseConcMarkSweepGC if the intent is to use the CMS collector.
info.cms.init.occupancy.only.missing=The CMS occupancy fraction, -XX:CMSInitiatingOccupancyFraction=N (default 92), is set without -XX:+UseCMSInitiatingOccupancyOnly enabled. Typically these options are used in combination with applications with large variances in object allocation and young generation promotion rates that prevent the CMS collector from accurately predicting when to start the CMS cycle. Consider adding/enabling -XX:+UseCMSInitiatingOccupancyOnly to disable heuristics (calculating anticipated promotions) and use only the occupancy fraction to determine when to trigger a CMS cycle.
info.comp.class.size.comp.class.disabled=Compressed class pointers space size is not being used due to compressed class pointers being disabled (-XX:-UseCompressedClassPointers).  
info.comp.class.size.comp.oops.disabled=Compressed class pointers space size is not being used due to compressed object references being disabled (-XX:-UseCompressedOops).
info.comp.class.size.not.set=When UseCompressedOops and UseCompressedClassesPointers (JDK 1.8 u40+) are enabled (default) the Metaspace reported in the GC logging is the sum of two native memory spaces: (1) class metadata. (2) compressed class pointers. It is recommended to explicitly set the compressed class pointers space. For example: -XX:CompressedClassSpaceSize=1G.
info.compile.threshold.ignored=The option -XX:CompileThreshold does not have any meaning when tiered compilation is enabled (default). It is ignored and can be removed.
info.cruft.exp.gc.inv.con.and.unl.cla=The option -XX:-ExplicitGCInvokesConcurrentAndUnloadsClasses is unnecessary and can be removed because explicit garbage collection is disabled with -XX:+DisableExplicitGC.
info.debug=The -Xdebug flag to enable debugging using the Java Virtual Machine Debug Interface (JVMDI) can be removed because JVMDI was removed in JDK7. Reference: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8227229.
info.diagnostic.vm.options.enabled=Diagnostic JVM options are enabled with -XX:+UnlockDiagnosticVMOptions. Diagnostic options add additional overhead and are intended for troubleshooting issues, not general production use.
info.eliminate.locks.enabled=-XX:+EliminateLocks is redundant (enabled by default) and can be removed. 
info.g1.summarize.rset.stats.output=Summarized remembered set processing output is enabled (e.g. -XX:+G1SummarizeRSetStats -XX:G1SummarizeRSetStatsPeriod=1). This is verbose logging generally enabled for short periods of time to address specific tuning issues. If there is not a good use case for this output, do not enable it.
info.gc.log.stdout=GC logging is being sent to stdout.
info.heap.dump.on.oome.missing=Consider adding -XX:+HeapDumpOnOutOfMemoryError, a standard recommended option to generate a heap dump when the first thread throws OutOfMemoryError. It does not impact performance (until the heap is actually written out) and generally should always be used, as it provides critical information in case of a memory error.
info.heap.dump.path.missing=Consider using -XX:HeapDumpPath to specify a directory where heap dumps are created (e.g. -XX:HeapDumpPath=/mypath/). If this option is not used, heap dumps will be created in the directory defined by the user.dir environment variable.
info.heap.max.missing=The maximum heap size is not being set. 
info.heap.min.not.equal.max=For non-container production environments, it is recommended to set the initial heap size (-Xms, -XX:InitialHeapSize) and the maximum heap size (-Xmx, -XX:MaxHeapSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the heap space. (2) If using large pages, memory is reserved for the JVM based on the maximum heap size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -Xms4096M -Xmx4096M.
info.instrumentation=Instrumentation is used:
info.jdk11.parallel.old.cruft=The parallel old collector is enabled/disabled with -XX:(+|-)UseParallelOldGC; however, the parallel collector is not being used. The option is ignored and can be removed.
info.jdk11.parallel.old.redundant=-XX:+UseParallelOldGC is redundant (enabled by default) and can be removed. The option is deprecated in JDK15 and removed in JDK16.
info.jdk11.print.gc.details.missing=Consider logging detailed gc information with -Xlog:gc* to output details needed for GC analysis (e.g. generation, metaspace, times data).
info.jdk8.cms.par.new.cruft=The CMS young collector is enabled/disabled with -XX:(+|-)UseParNewGC; however, the CMS collector is not being used. The option is ignored and can be removed.
info.jdk8.cms.par.new.redundant=-XX:+UseParNewGC is redundant (enabled by default) and can be removed. The option is deprecated in JDK8 and removed in JDK9.
info.jdk8.print.adaptive.resize.plcy.disabled=Adaptive Resize Policy output is disabled with -XX:-PrintAdaptiveSizePolicy. It is disabled by default, so this option is redundant. Verify the intent is not to enable it with -XX:+PrintAdaptiveSizePolicy.
info.jdk8.print.adaptive.resize.plcy.enabled=Adaptive Resize Policy output is enabled with -XX:+PrintAdaptiveSizePolicy. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.jdk8.print.fls.statistics=The -XX:PrintFLSStatistics option is used. The additional data output with this option is not typically needed and adds significant logging overhead. If there is not a good use case for using this option, remove it.
info.jdk8.print.gc.cause=-XX:+PrintGCCause is unnecessary (enabled by default) and could be removed.
info.jdk8.print.gc.details.missing=Consider logging detailed gc information with -XX:+PrintGCDetails to output details needed for GC analysis (e.g. generation, metaspace, times data).
info.jdk8.print.heap.at.gc=The -XX:+PrintHeapAtGC option is causing additional heap information to be output in the gc log. The additional data is not typically used for gc analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.jdk8.print.promotion.failure=The -XX:+PrintPromotionFailure option is used. The additional data output with this option is not generally needed. If there is not a good use case for using this option, consider removing it.
info.jdk8.print.reference.gc.enabled=Consider removing -XX:+PrintReferenceGC. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.jdk8.print.string.dedup.stats.enabled=Consider removing -XX:+PrintStringDeduplicationStatistics. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.jdk8.print.tenuring.distribution=The -XX:+PrintTenuringDistribution option is enabled. The additional data output with this option is not typically used for gc analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.jdk9.deprecated.loggc=-Xloggc was deprecated in JDK9. The JVM translates -Xloggc to the equivalent -Xlog option (e.g. -Xloggc:gc_%p_%t.log --> -Xlog:gc:gc_%p_%t.log); however, it is recommended to remove -Xloggc and use -Xlog directly to avoid confusion and unintended results.
info.jdk9.deprecated.print.gc.details=-XX:+PrintGCDetails was deprecated in JDK9. The JVM translates -XX:+PrintGCDetails to the equivalent -Xlog option (e.g. -XX:+PrintGC --> -Xlog:gc*); however, it is recommended to remove -XX:+PrintGCDetails and use -Xlog directly to avoid confusion and unintended results.
info.jdk9.deprecated.print.gc=-XX:+PrintGC was deprecated in JDK9. The JVM translates -XX:+PrintGC to the equivalent -Xlog option (e.g. -XX:+PrintGC --> -Xlog:gc); however, it is recommended to remove -XX:+PrintGC and use -Xlog directly to avoid confusion and unintended results.
info.jfr=JDK Flight Recorder (JFR) is used.
info.jmx.enabled=JMX is enabled with -Dcom.sun.management.jmxremote or -XX:+ManagementServer. This alone does not add significant overhead; however, there is additional overhead when a tool (e.g. jconsole) polls for information. The impact on performance will depend on what is polled and how often.
info.large.page.size.in.bytes.linux=-XX:LargePageSizeInBytes has no meaning on Linux and can be removed. The page size is determined by the page size the kernel is set to support (Hugepagesize).
info.large.page.size.in.bytes.windows=-XX:LargePageSizeInBytes has no meaning on Windows and can be removed. The page size is fixed at 2MB. 
info.max.perm.size=There is an attempt to set the maximum permanent generation size with -XX:MaxPermSize. The permanent generation space was replaced by the metaspace in JDK8. The option is ignored and should be removed.
info.max.tenuring.override=The number of times an object is copied between survivor spaces is set with -XX:MaxTenuringThreshold=N (0-15). 0 = disabled. 15 (default) = promote when the survivor space fills. Unless testing has shown this improves performance, consider removing this option to allow the default value to be applied.
info.metaspace.class.metadata.and.comp.class.space=Metaspace includes class metadata plus compressed class space.
info.metaspace.class.metadata=Metaspace includes class metadata only (no compressed class space).
info.metaspace=Initial and/or max metaspace size is set. This is generally not recommended. Reference: https://access.redhat.com/solutions/1489263.
info.min.heap.delta.bytes=The minimum amount to resize the heap space is set with -XX:MinHeapDeltaBytes=N. If there is not a good use case, remove it and let JVM ergonomics decide.
info.missing=No JVM options.
info.native.agent=Native agent library is used:
info.new.ratio.inverted=The young generation is larger than the tenured generation. It's possible this is optimal for the application object lifetimes; however, the tenured generation is typically larger. Ensure that testing supports the larger young generation, as the young:tenured ratio has a major impact on generational collector performance.
info.on.oome.kill=-XX:OnOutOfMemoryError is used to shut down the JVM when the first OutOfMemoryError happens. -XX:+ExitOnOutOfMemoryError is available for this purpose since JDK8 u92. Reference: https://access.redhat.com/solutions/3645742.
info.on.oome=-XX:OnOutOfMemoryError is used to execute a command or script when the first OutOfMemoryError happens. Reference: https://access.redhat.com/solutions/3645742.
info.opts.none=No JVM options.
info.opts.undefined=Undefined JVM option(s):
info.parallel.gc.threads.serial=Setting the number of parallel garbage collection threads with -XX:ParallelGCThreads=N has no meaning with the serial collector and should be removed.
info.parallel.gc.threads=The number of parallel garbage collection threads is set with -XX:ParallelGCThreads=N. Unless multiple JVMs and/or processes are collocated and competing for resources, it's generally best to remove this option and let JVM determine an appropriate setting (JDK8) or manage it dynamically with ergonomics (JDK11+).
info.perf.data.disabled=Consider replacing -XX:-UsePerfData with -XX:+PerfDisableSharedMem. This will disable the writing of performance data to disk (/tmp/hsperfdata*) but still make it available via JMX.
info.perm.size=There is an attempt to set the initial permanent generation size with -XX:PermSize. The permanent generation space was replaced by the metaspace in JDK8. The option is ignored and should be removed.
info.print.gc.application.concurrent.time=Remove -XX:+PrintGCApplicationConcurrentTime. It is redundant, as the same information can be calculated from the GC logging timestamps and durations. It adds overhead with no analysis value.
info.rmi.dgc.client.gcInterval.redundant=The sun.rmi.dgc.client.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
info.rmi.dgc.server.gcInterval.redundant=The sun.rmi.dgc.server.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
info.survivor.ratio.target=Target survivor ratio, the percentage of the survivor space allowed to be occupied, is set with -XX:TargetSurvivorRatio=N (e.g. -XX:TargetSurvivorRatio=90).
info.survivor.ratio=Survivor ratio, the size of the eden space compared to ONE survivor space, is set with -XX:SurvivorRatio=N (e.g. -XX:SurvivorRatio=6).
info.tiered.compilation.enabled=-XX:+TieredCompilation is redundant and can be removed, as tiered compilation is enabled by default in JDK8+.
info.trace.class.loading=The -XX:+TraceClassLoading option is enabled, causing class loading information to be output. This is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it.
info.trace.class.unloading=The -XX:+TraceClassUnloading option is enabled, causing class unloading information to be output. This is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it.
info.verbose.class=Class loading logging is enabled with -verbose:class. This is not a standard recommended logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less overhead.
warn.adaptive.size.policy.disabled=Adaptive size policy is disabled (-XX:-UseAdaptiveSizePolicy), and minimum heap size (-Xms, -XX:InitialHeapSize) and maximum heap size (-Xmx, -XX:MaxHeapSize) are not equal. The JVM will not be able to increase the heap beyond the minimum heap size. Remove -XX:-UseAdaptiveSizePolicy. Reference: https://access.redhat.com/solutions/5565311.
warn.biased.locking.disabled=Biased locking is disabled. Biased locking is a threading optimization that benefits objects that are only locked by a single thread. This is the typical use case, and it is enabled by default. Consider removing -XX:-UseBiasedLocking unless testing has shown that disabling biased locking improves performance.
warn.bytecode.back.comp.disabled=Bytecode background compilation is disabled. Remove -Xbatch or -XX:-BackgroundCompilation to compile bytecode in the background so threads do not block waiting but instead run in interpreter mode until the compilation is complete.
warn.bytecode.compile.disabled=Compilation to native code is disabled. Remove -Xint to allow the just in time (JIT) compiler to compile to native code for increased performance.
warn.bytecode.compile.first.invocation=Methods being compiled on first invocation. Remove -Xcomp to enabled the JVM to efficiently decide when to compile methods into bytecode.
warn.cgroup.memory.limit.override=An attempt to set the maximum heap size with -XX:+UseCGroupMemoryLimitForHeap is being overridden by -Xmx/-XX:MaxHeapSize. -XX:+UseCGroupMemoryLimitForHeap is an experimental option replaced by auto-detection of container limits in recent JDKs and removed altogether in JDK 11. See: https://bugs.openjdk.java.net/browse/JDK-8194086.
warn.cgroup.memory.limit=The maximum heap size is being set with -XX:+UseCGroupMemoryLimitForHeap, an experimental option replaced by auto-detection of container limits in recent JDKs and removed altogether in JDK 11. See: https://bugs.openjdk.java.net/browse/JDK-8194086.
warn.class.histogram=Class histogram output in gc logging due to one of the following options: -XX:+PrintClassHistogram, -XX:+PrintClassHistogramBeforeFullGC, -XX:+PrintClassHistogramAfterFullGC. These are heavyweight options that can output tens of thousands of logging lines and have limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this output, do not enable it.
warn.class.unloading.disabled=Class unloading is disabled with -XX:-ClassUnloading. Remove to allow the default unloading unreachable classes to collect metaspace.
warn.cms.class.unloading.disabled=CMS collection of metaspace is disabled with -XX:-CMSClassUnloadingEnabled. Remove to allow the default unloading unreachable classes to collect metaspace in the CMS concurrent cycle and avoid metaspace collections being done by a slow (single threaded) serial collector.
warn.cms.inc.mode.with.init.occup.fract=When the CMS collector is run in incremental mode, the CMS initiating occupancy fraction is ignored. Remove one of the following options: (1) -XX:+CMSIncrementalMode, (2) -XX:CMSInitiatingOccupancyFraction=<n>.
warn.cms.parallel.initial.mark.disabled=Multi-threaded CMS initial mark is disabled with -XX:-CMSParallelInitialMarkEnabled. Remove -XX:-CMSParallelInitialMarkEnabled and let the JVM determine the setting based on resources.
warn.cms.parallel.remark.disabled=Multi-threaded CMS remark is disabled with -XX:-CMSParallelRemarkEnabled. Remove -XX:-CMSParallelRemarkEnabled and let the JVM determine the setting based on resources.
warn.comp.class.disabled.heap.lt.32g=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.comp.class.disabled.heap.unk=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.comp.class.enabled.heap.gt.32g=Compressed class pointers are enabled with -XX:+UseCompressedClassPointers, and heap >= 32G. Compressed object references cannot be used on heaps >= 32G. Remove -XX+-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.comp.class.size.heap.gt.32g=Compressed class pointers space size is set (-XX:CompressedClassSpaceSize), and heap >= 32G. Remove -XX:CompressedClassSpaceSize, as compressed object references should not be used on heaps >= 32G.
warn.comp.oops.disabled.heap.lt.32g=Compressed object references are disabled with -XX:-UseCompressedOops, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.comp.oops.disabled.heap.unk=Compressed object references are disabled with -XX:-UseCompressedOops. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.comp.oops.enabled.heap.gt.32g=Compressed object references are enabled with -XX:+UseCompressedOops, and heap >= 32G. Compressed object references should not be used on heaps >= 32G. Remove -XX:+UseCompressedOops and let the JVM determine the setting based on resources.
warn.concurrentio=Remove -Xconcurrentio, an old/undocumented/non-standard option that was removed in JDK 12 due to having no known use cases. It makes changes to JVM settings that are contrary to best practices with modern JVMs. Reference: https://bugs.openjdk.org/browse/JDK-8213767.
warn.container.perf.data.disk=If this is a container environment, it is recommended to disable the writing of performance data to disk (/tmp/hsperfdata*) with -XX:+PerfDisableSharedMem. Disk IOPS (Input/output Operations Per Second) is shared among containers. Eliminating disk access will prevent one workload monopolizing disk from impacting all containers.
warn.diagnostic.debug.non.safepoints=Diagnostic non safepoint debugging is enabled with -XX:+DebugNonSafepoints to improve JDK Flight Recorder (JFR) method profiling accuracy. It adds overhead and should be removed when relevant troubleshooting is completed.
warn.diagnostic.guaranteed.safepoint.interval=Diagnostic guaranteed safepoint interval is set with -XX:GuaranteedSafepointInterval=N. It should be removed when relevant troubleshooting is completed.
warn.diagnostic.print.safepoint.statistics=Diagnostic safepoint logging is enabled (e.g. -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 -XX:+LogVMOutput -XX:LogFile=/path/to/vm.log). It should be removed when relevant troubleshooting is completed.
warn.diagnostic.unsyncload.class=Diagnostic parallel class loading is enabled with with -XX:+UnsyncloadClass. It is extremely unsafe and should be removed when relevant troubleshooting is completed. Reference: https://bugs.openjdk.java.net/browse/JDK-8140284.
warn.disable.attach.mechanism=jcmd, jmap, and jstack will not work because the creation of the AttachListener socket file (/tmp/.java_pid<pid>) used to communicate with the JVM is disabled with -XX:+DisableAttachMechanism.
warn.experimental.vm.options.enabled=Experimental options are enabled with -XX:+UnlockExperimentalVMOptions. Experimental options are generally not recommended/supported for production. Consider removing this option and any related experimental options.
warn.explicit.gc.disabled.concurrent=Remove -XX:+ExplicitGCInvokesConcurrent since explicit garbage collection is disabled with -XX:+DisableExplicitGC.
warn.explicit.gc.disabled=Explicit garbage collection is disabled with -XX:+DisableExplicitGC. The JVM uses explicit garbage collection to manage direct memory (to free space when MaxDirectMemorySize is reached) and the Remote Method Invocation (RMI) system (to clean up unreachable remote objects). Disabling it for those use cases can cause a memory leak. Verify the application does not use direct memory (e.g. java.nio.DirectByteBuffer), does not make remote method calls or export remote objects like EJBs (everything runs in the same JVM), and does not depend on explicit garbage collection in some other way. Known applications that use direct memory: JBoss EAP7 (IO subsystem). If explicit garbage collection is required, remove -XX:+DisableExplicitGC, and if using the CMS or G1 collector, add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
warn.explicit.gc.not.concurrent=Consider adding -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently by the CMS and G1 collectors. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection altogether with -XX:+DisableExplicitGC. Reference: https://access.redhat.com/solutions/21994.
warn.fast.unordered.timestamps=Fast unordered timestamps are enabled with -XX:+UseFastUnorderedTimeStamps. Consider removing this option, as it is an experimental option known to cause logging issues.
warn.g1.mixed.gc.live.thrshld.prcnt=The occupancy threshold for a region to be considered as a candidate region for a G1_CLEANUP collection is set with the -XX:G1MixedGCLiveThresholdPercent=N (default 65% JDK7/JDK8 < u40, 85% JDK8u40+). Consider removing this experimental option unless there is a valid use case (e.g. JDK8 <  u40: https://bugs.openjdk.java.net/browse/JDK-8059452) and testing has shown it does not introduce any issues.
warn.heap.dump.on.oome.disabled=Remove -XX:-HeapDumpOnOutOfMemoryError and add -XX:+HeapDumpOnOutOfMemoryError instead (notice "+" vs. "-") for a heap dump to be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error.
warn.heap.dump.path.filename=A heap dump file name is specified with -XX:HeapDumpPath (e.g. -XX:HeapDumpPath=/mydir/heapdump.hprof). Heap dumps will not overwrite each other, so only an initial heap dump will be output. Subsequent heap dumps will fail due to the existing file. Unless disk space is a concern, configure to not lose data by specifying a directory (e.g. -XX:HeapDumpPath=/mydir/) and let the JVM use the default file name (which includes the process id). Reference: https://access.redhat.com/solutions/21109.
warn.jdk11.gc.log.file.overwrite=The gc log file has a static name and will be overwritten on JVM startup. Enable log file rotation and/or include a process or datestamp in the file name (e.g. -Xlog:gc*:file=gc_%p_%t.log:time,uptime:filecount=0,filesize=5M).
warn.jdk11.gc.log.file.rotation.disabled=GC log file rotation is disabled with filecount=0. Set filecount to a non-zero value or remove it (default 5) to enable GC log file rotation.
warn.jdk11.gc.log.file.size.0=Automatic GC log file rotation is disabled with filesize=0. Set filesize to a non-zero value or remove it (default 20M) to allow automatic log rotation.
warn.jdk11.gc.log.file.size.small=GC log file size (filesize=N[K|M|G]) is small (< 5M). Data needed for troubleshooting could be lost due to excessive log rotation. Consider increasing the size.
warn.jdk11.parallel.old.disabled=The multi-threaded parallel old collector (default) is disabled with -XX:-UseParallelOldGC, resulting in the serial old collector being used. Remove -XX:-UseParallelOldGC.
warn.jdk8.cms.par.new.disabled=The PAR_NEW collector is disabled with -XX:-UseParNewGC, resulting in the SERIAL_NEW collector being used instead. Serial collectors are single-thread, which means they can take a long time to collect a large heap. For optimal performance on multi cpu/core systems, remove -XX:-UseParNewGC to enable the default PAR_NEW collector. Deprecated in JDK8 and removed in JDK9 (only the PAR_NEW collector can be used in combination with the CMS collector). 
warn.jdk8.gc.log.file.overwrite=The gc log file has a static name and will be overwritten on JVM startup. Enable log file rotation and/or include process id or datestamp in the file name (e.g. -Xloggc:gc_%p_%t.log).
warn.jdk8.gc.log.file.rotation.disabled.num=Number of GC log files is defined (-XX:NumberOfGCLogFiles), yet GC log file rotation is disabled. Either remove -XX:NumberOfGCLogFiles or enable GC log file rotation with -XX:+UseGCLogFileRotation.
warn.jdk8.gc.log.file.rotation.disabled=GC log file rotation is disabled (-XX:-UseGCLogFileRotation). Consider enabling rotation to protect disk space.
warn.jdk8.gc.log.file.rotation.not.enabled=Consider enabling gc log file rotation (-XX:+UseGCLogFileRotation -XX:GCLogFileSize=N[K|M|G] -XX:NumberOfGCLogFiles=N) to protect disk space.
warn.jdk8.gc.log.file.size.small=GC log file size (-XX:GCLogFileSize=N[K|M|G]) is small (< 5M). Data needed for troubleshooting could be lost due to excessive log rotation. Consider increasing the size.
warn.jdk8.print.gc.cause.disabled=Remove -XX:-PrintGCCause so trigger information critical for analysis will be output in gc logging (default behavior).
warn.jdk8.print.gc.details.disabled=PrintGCDetails is disabled. This is a standard recommended logging option that outputs details needed for GC analysis (e.g. generation, Metaspace, and Times data). Replace -XX:-PrintGCDetails with -XX:+PrintGCDetails. Or, if both -XX:-PrintGCDetails and -XX:+PrintGCDetails are set, remove -XX:-PrintGCDetails.
warn.jdk8.use.vm.interruptible.io=-XX:-UseVMInterruptibleIO is obsolete and should be removed. It is deprecated in JDK8 and removed in JDK11. 
warn.metaspace.lt.comp.class=MaxMetaspaceSize is less than CompressedClassSpaceSize. MaxMetaspaceSize includes CompressedClassSpaceSize, so MaxMetaspaceSize should be larger than CompressedClassSpaceSize. If MaxMetaspaceSize is set smaller than CompressedClassSpaceSize, the JVM auto adjusts CompressedClassSpaceSize as follows: CompressedClassSpaceSize = MaxMetaspaceSize - (2 * InitialBootClassLoaderMetaspaceSize).
warn.print.class.histogram.after.full.gc=The -XX:+PrintClassHistogramAfterFullGC option will cause a class histogram to be output after every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.print.class.histogram.before.full.gc=The -XX:+PrintClassHistogramBeforeFullGC option will cause a class histogram to be output before every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.print.class.histogram=The -XX:+PrintClassHistogram option will cause a class histogram to be output in the gc logging when a thread dump is taken. It is a heavyweight option that forces a full collection and can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.rmi.dgc.client.gcInterval.large=The sun.rmi.dgc.client.gcInterval value is large (> 24 hours). A typical value is at 1-4 hours (e.g. 4 hours: -Dsun.rmi.dgc.client.gcInterval=14400000). If Java Remote Method Invocation (Java RMI) is loaded and used, the interval may be too small and cause a memory leak, as Java RMI depends on regular collections to clean up unreachable objects. If Java RMI is not used, the option can be removed.
warn.rmi.dgc.client.gcInterval.small=The sun.rmi.dgc.client.gcInterval value is small (< 1 hour). A typical value is at least one hour (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000). If Java Remote Method Invocation (Java RMI) is loaded and used, this could cause excessive garbage collections.
warn.rmi.dgc.server.gcInterval.large=The sun.rmi.dgc.server.gcInterval value is large (> 24 hours). A typical value is at 1-4 hours (e.g. 4 hours: -Dsun.rmi.dgc.server.gcInterval=14400000). If Java Remote Method Invocation (Java RMI) is loaded and used, the interval may be too small and cause a memory leak, as Java RMI depends on regular collections to clean up unreachable objects. If Java RMI is not used, the option can be removed.
warn.rmi.dgc.server.gcInterval.small=The sun.rmi.dgc.server.gcInterval value is small (< 1 hour). A typical value is at least one hour (e.g. -Dsun.rmi.dgc.server.gcInterval=3600000). If Java Remote Method Invocation (Java RMI) is loaded and used, this could cause excessive garbage collections.
warn.rs=-Xrs prevents the JVM from handling signals. Issuing kill -3 or CTRL+Break will not work and will cause the Java processes to be terminated.
warn.shenandoah.guaranteed.gc.interval=The number of milliseconds for a guaranteed GC cycle is being set with -XX:ShenandoahGuaranteedGCInterval=N, an experimental option.
warn.shenandoah.uncommit.delay=The number of milliseconds for before unused memory in the page cache is evicted is being set with -XX:ShenandoahUncommitDelay=N, an experimental option.
warn.tenuring.disabled=Tenuring is disabled with -XX:MaxTenuringThreshold=0 or by setting it to a value greater than 15 (e.g. -XX:MaxTenuringThreshold=32), resulting in objects surviving a young collection not being copied to a survivor space but being immediately promoted to the old generation. Unless testing has shown this makes sense for your application (e.g. mainly long live objects), consider removing this option to allow the default value to be applied.
warn.thread.stack.size.small=Thread stack size is less than 128K.
warn.thread.stack.size.tiny=Thread stack size is less than 1K. Were units (e.g. 'K') left off by mistake? 
warn.use.membar=The -XX:+UseMembar option is used. This was a workaround for a bug in old versions of JDK 1.6 (see https://bugs.openjdk.org/browse/JDK-6822370) and is not necessary with modern JVMs. If there is not a good use case for using this option, remove it, as it causes the JVM to use a memory barrier that slows down the JVM.
warn.verify.none=Class verification during loading is disabled with -Xverify:none. This is unsupported and can result in corrupt or invalid classes being loaded, causing undetermined JVM behavior and crashes.