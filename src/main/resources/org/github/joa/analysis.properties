error.cms.missing=Add -XX:+UseConcMarkSweepGC to use the CMS collector for the old generation. When -XX:+UseParNewGC is used alone the CMS collector is only used to collect the young generation, and the older, slower serial collector is used to collect the old generation.
error.jdk8.cms.par.new.disabled=The PAR_NEW collector is disabled with -XX:-UseParNewGC, resulting in the SERIAL_NEW collector being used instead. Serial collectors are single-thread, which means they can take a long time to collect a large heap. For optimal performance on multi cpu/core systems, remove -XX:-UseParNewGC to enable the default PAR_NEW collector. Deprecated in JDK8 and removed in JDK9 (only the PAR_NEW collector can be used in combination with the CMS collector).
error.jdk8.use.cms.compaction.at.full.collection.enabled=The -XX:+UseCMSCompactAtFullCollection option is being used to specify that full collections (e.g. concurrent mode failure) be handled by the CMS collector running in "foreground" mode. This is very slow, has no real use cases, was deprecated in JDK8, and removed in JDK9. Remove -XX:+UseCMSCompactAtFullCollection to allow the default serial old collector to be used instead.
error.dups=Duplicate jvm options: 
error.g1.ignored.parallel=The JVM is not using the G1 collector specified in the JVM options and using the parallel collector instead.
error.gc.ignored=The JVM is not using the GC collector specified in the JVM options.
error.par.new.serial.old=The multi-threaded CMS collector is disabled with -XX:-UseParallelOldGC, resulting in the serial old collector being used. Replace -XX:-UseParallelOldGC with -XX:+UseConcMarkSweepGC to use the multi-threaded CMS collector.
error.parallel.gc.threads.1=A multi-threaded garbage collector is restricted to a single thread with -XX:ParallelGCThreads=1. Multi-threaded garbage collectors require multiple CPUs to work efficiently. The serial collector is more appropriate for single cpu environments.
error.parallel.scavenge.parallel.serial.old=The multi-threaded parallel old collector is disabled with -XX:-UseParallelOldGC, resulting in the serial old collector being used. Remove -XX:-UseParallelOldGC to use the multi-threaded parallel old collector.
error.ram.pct.initial.gt.max=InitialRAMPercentage > MaxRAMPercentage.
error.ram.pct.initial.gt.min=InitialRAMPercentage > MinRAMPercentage.
error.ram.pct.initial.100=InitialRAMPercentage >= 100. Initial cannot be >= 100 because the JVM process includes more memory than just the Java heap (e.g. metaspace, code cache, stack, native memory).
error.ram.pct.max.100=MaxRAMPercentage >= 100. Max cannot be >= 100 because the JVM process includes more memory than just the Java heap (e.g. metaspace, code cache, stack, native memory).
error.ram.pct.min.100=MinRAMPercentage >= 100. Min cannot be >= 100 because the JVM process includes more memory than just the Java heap (e.g. metaspace, code cache, stack, native memory).
error.remote.debugging.enabled=Remote debugging is enabled (e.g. -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n or -Xrunjdwp:transport=dt_socket,server=y,address=8787,suspend=n). This is for debugging in lower environments and should not be enabled in production due to performance, security, and stability concerns.
info.64.client=The -client flag no longer serves a purpose in 64-bit JDK8+ and can be removed. Only the server JIT compiler is included in 64-bit JDKs.
info.64.d64.redundant=The -d64 flag does not serve a purpose in JDK8 and is removed in JDK11. It can be removed, as only the server JIT compiler is included in 64-bit JDKs.
info.64.server.redundant=The -server flag no longer serves a purpose in JDK8+ and can be removed, as only the server JIT compiler is included in 64-bit JDKs.
info.active.processor.count=The number of cpu/cores is being explicitly set with -XX:ActiveProcessorCount=N. Unless multiple JVMs and/or processes are collocated and competing for resources, it's generally best to remove this option and let the JVM determine cpu/cores from cgroup settings.
info.ci.compiler.count=The number of compiler threads is set with -XX:CICompilerCount=N. Unless multiple JVMs and/or processes are collocated and competing for resources, it's generally best to remove this option and let JVM determine an appropriate setting (JDK8) or manage it dynamically with ergonomics (JDK11+).
info.cms.disabled=The CMS collector is disabled with -XX:-UseParNewGC -XX:-UseConcMarkSweepGC (JDK8) or -XX:-UseConcMarkSweepGC (JDK8/11), resulting in the default collector being used. Remove the option(s) if the intent is to use the default collector. Replace the option(s) with -XX:+UseConcMarkSweepGC if the intent is to use the CMS collector.
info.cms.eden.chunks.record.always=The flag to always record CMS parallel initial mark/remark eden chunks is set with -XX:(+|-)CMSEdenChunksRecordAlways. This is not a standard recommended option. Unless testing has shown this improves performance, consider removing this option to allow the default value to be applied.
info.cms.incremental.mode=The CMS collector is being run in incremental mode. Concurrent phases are periodically stopped so application threads can run. This is useful on systems with 1-2 processors that cannot afford to dedicate cpu to the concurrent phases. Remove -XX:+CMSIncrementalMode if > 2 cpu/cores.
info.cms.init.occupancy.only.missing=The CMS occupancy fraction, -XX:CMSInitiatingOccupancyFraction=N (default 92), is set without -XX:+UseCMSInitiatingOccupancyOnly enabled. Typically these options are used in combination with applications with large variances in object allocation and young generation promotion rates that prevent the CMS collector from accurately predicting when to start the CMS cycle. Consider adding/enabling -XX:+UseCMSInitiatingOccupancyOnly to disable heuristics (calculating anticipated promotions) and use only the occupancy fraction to determine when to trigger a CMS cycle.
info.cms.wait.duration=The milliseconds the CMS collector will wait before starting an initial mark after a young collection is set with -XX:CMSWaitDuration=N. This is not a standard recommended option. Unless testing has shown this improves performance, consider removing this option to allow the default value to be applied.
info.comp.class.size.comp.class.disabled=Compressed class pointers space size is not being used due to compressed class pointers being disabled (-XX:-UseCompressedClassPointers).  
info.comp.class.size.comp.oops.disabled=Compressed class pointers space size is not being used due to compressed object references being disabled (-XX:-UseCompressedOops).
info.compile.threshold.ignored=The option -XX:CompileThreshold does not have any meaning when tiered compilation is enabled (default). It is ignored and can be removed.
info.cruft.exp.gc.inv.con.and.unl.cla=The option -XX:-ExplicitGCInvokesConcurrentAndUnloadsClasses is unnecessary and can be removed because explicit garbage collection is disabled with -XX:+DisableExplicitGC.
info.debug=The -Xdebug flag to enable debugging using the Java Virtual Machine Debug Interface (JVMDI) can be removed because JVMDI was removed in JDK7. Reference: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8227229.
info.diagnostic.vm.options.enabled=Diagnostic options. The following should be removed when relevant troubleshooting is completed, as they add additional overhead and are not recommended/supported for general production use: -XX:+UnlockDiagnosticVMOptions
info.eliminate.locks.enabled=-XX:+EliminateLocks is redundant (enabled by default) and can be removed.
info.fast.unordered.timestamps=Fast unordered timestamps enabled by JVM ergonomics. 
info.g1.summarize.rset.stats.output=Summarized remembered set processing output is enabled (e.g. -XX:+G1SummarizeRSetStats -XX:G1SummarizeRSetStatsPeriod=1). This is verbose logging generally enabled for short periods of time to address specific tuning issues. If there is not a good use case for this output, do not enable it.
info.gc.log.stdout=GC logging is being sent to stdout.
info.gc.overhead.limit.disabled="java.lang.OutOfMemoryError: GC overhead limit exceeded", thrown when more than 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered, is disabled with -XX:-UseGCOverheadLimit. This is a throttle enabled by default to prevent a misbehaving java process from bringing down an entire environment.
info.heap.dump.on.oome.missing=Consider adding -XX:+HeapDumpOnOutOfMemoryError, a standard recommended option to generate a heap dump when the first thread throws OutOfMemoryError. It does not impact performance (until the heap is actually written out) and generally should always be used, as it provides critical information in case of a memory error.
info.heap.dump.path.missing=Consider using -XX:HeapDumpPath to specify a directory where heap dumps are created (e.g. -XX:HeapDumpPath=/mypath/). If this option is not used, heap dumps will be created in the directory defined by the user.dir environment variable.
info.heap.max.missing=The maximum heap size is not being set. 
info.heap.min.not.equal.max=For non-container production environments, it is recommended to set the initial heap size (-Xms, -XX:InitialHeapSize) and the maximum heap size (-Xmx, -XX:MaxHeapSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the heap space. (2) If using large pages, memory is reserved for the JVM based on the maximum heap size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -Xms4096M -Xmx4096M.
info.ignore.unrecognized.vm.options=-XX:+IgnoreUnrecognizedVMOptions is causing unrecognized JVM options to be ignored. This is not a best practice, as it prevents testing, causing unexpected results due to typos and options removed between releases.
info.instrumentation=Instrumentation is used:
info.jdk11.print.gc.details.missing=Consider logging detailed gc information with -Xlog:gc* to output details needed for GC analysis (e.g. generation, metaspace, times data).
info.jdk8.cms.par.new.cruft=The CMS young collector is enabled/disabled with -XX:(+|-)UseParNewGC; however, the CMS collector is not being used. The option is ignored and can be removed.
info.jdk8.cms.par.new.redundant=-XX:+UseParNewGC is redundant (enabled by default) and can be removed. Deprecated in JDK8 and removed in JDK9.
info.jdk8.print.adaptive.resize.plcy.disabled=Adaptive Resize Policy output is disabled with -XX:-PrintAdaptiveSizePolicy. It is disabled by default, so this option is redundant. Verify the intent is not to enable it with -XX:+PrintAdaptiveSizePolicy.
info.jdk8.print.adaptive.resize.plcy.enabled=Adaptive Resize Policy output is enabled with -XX:+PrintAdaptiveSizePolicy. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.jdk8.print.fls.statistics=The -XX:PrintFLSStatistics option is used. The additional data output with this option is not typically needed and adds significant logging overhead. If there is not a good use case for using this option, remove it.
info.jdk8.print.gc.cause=-XX:+PrintGCCause is unnecessary (enabled by default) and can be removed.
info.jdk8.print.heap.at.gc=The -XX:+PrintHeapAtGC option is causing additional heap information to be output in the gc log. The additional data is not typically used for gc analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.jdk8.print.promotion.failure=The -XX:+PrintPromotionFailure option is used. The additional data output with this option is not generally needed. If there is not a good use case for using this option, consider removing it.
info.jdk8.print.reference.gc.enabled=Consider removing -XX:+PrintReferenceGC. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.jdk8.print.string.dedup.stats.enabled=Consider removing -XX:+PrintStringDeduplicationStatistics. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.jdk8.print.string.table.stats.enabled=Consider removing -XX:+PrintStringTableStatistics. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.jdk8.print.tenuring.distribution=The -XX:+PrintTenuringDistribution option is enabled. The additional data output with this option is not typically used for gc analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.jdk8.print.tenuring.distribution.disabled=-XX:-PrintTenuringDistribution is redundant (disabled by default) and can be removed. 
info.jdk9.deprecated.loggc=-Xloggc was deprecated in JDK9. The JVM translates -Xloggc to the equivalent -Xlog option (e.g. -Xloggc:gc_%p_%t.log --> -Xlog:gc:gc_%p_%t.log); however, it is recommended to remove -Xloggc and use -Xlog directly to avoid confusion and unintended results.
info.jdk9.deprecated.print.gc.details=-XX:+PrintGCDetails was deprecated in JDK9. The JVM translates -XX:+PrintGCDetails to the equivalent -Xlog option (e.g. -XX:+PrintGC --> -Xlog:gc*); however, it is recommended to remove -XX:+PrintGCDetails and use -Xlog directly to avoid confusion and unintended results.
info.jdk9.deprecated.print.gc=-XX:+PrintGC was deprecated in JDK9. The JVM translates -XX:+PrintGC to the equivalent -Xlog option (e.g. -XX:+PrintGC --> -Xlog:gc); however, it is recommended to remove -XX:+PrintGC and use -Xlog directly to avoid confusion and unintended results.
info.jfr=JDK Flight Recorder (JFR) is used.
info.jfr.flight.recorder.disabled=JDK Flight Recorder is disabled with -XX:-FlightRecorder, a flag that is deprecated in JDK13. Reference:  https://bugs.openjdk.org/browse/JDK-8225312.
info.jfr.flight.recorder.enabled=JDK Flight Recorder is enabled with -XX:+FlightRecorder, a flag that is unnecessary after JDK8 u240 and deprecated in JDK13. Reference:  https://bugs.openjdk.org/browse/JDK-8225312.
info.jmx.enabled=JMX is enabled with -Dcom.sun.management.jmxremote or -XX:+ManagementServer. This alone does not add significant overhead; however, there is additional overhead when a tool (e.g. jconsole) polls for information. The impact on performance will depend on what is polled and how often.
info.large.page.size.in.bytes.linux=-XX:LargePageSizeInBytes has no meaning on Linux and can be removed. The page size is determined by the page size the kernel is set to support (Hugepagesize).
info.large.page.size.in.bytes.windows=-XX:LargePageSizeInBytes has no meaning on Windows and can be removed. The page size is fixed at 2MB. 
info.max.fd.limit.ignored=-XX:(+|-)MaxFDLimit is being ignored and can be removed (it applies only to solaris).
info.max.perm.size=There is an attempt to set the maximum permanent generation size with -XX:MaxPermSize. The permanent generation space was replaced by the metaspace in JDK8. The option is ignored and should be removed.
info.max.tenuring.override=The number of times an object is copied between survivor spaces is set with -XX:MaxTenuringThreshold=N (0-15). 0 = disabled. 15 (default) = promote when the survivor space fills. Unless testing has shown this improves performance, consider removing this option to allow the default value to be applied.
info.metaspace.class.metadata=Metaspace = Class Metadata only (no Compressed Class Space).
info.metaspace.class.metadata.and.comp.class.space=Metaspace = Class Metadata + Compressed Class Space.
info.metaspace=Initial and/or max metaspace size is set. This is generally not recommended. Reference: https://access.redhat.com/solutions/1489263.
info.min.heap.delta.bytes=The minimum amount to resize the heap space is set with -XX:MinHeapDeltaBytes=N. If there is not a good use case, remove it and let JVM ergonomics decide.
info.missing=No JVM options.
info.native.agent=Native agent library is used:
info.new.ratio.inverted=The young generation is larger than the tenured generation. It's possible this is optimal for the application object lifetimes; however, the tenured generation is typically larger. Ensure that testing supports the larger young generation, as the young:tenured ratio has a major impact on generational collector performance.
info.on.oome.kill=-XX:OnOutOfMemoryError is used to shut down the JVM when the first OutOfMemoryError happens. -XX:+ExitOnOutOfMemoryError is available for this purpose since JDK8 u92. Reference: https://access.redhat.com/solutions/3645742.
info.on.oome=-XX:OnOutOfMemoryError is used to execute a command or script when the first OutOfMemoryError happens. Reference: https://access.redhat.com/solutions/3645742.
info.opts.undefined=Undefined JVM option(s):
info.parallel.gc.threads.serial=Setting the number of parallel garbage collection threads with -XX:ParallelGCThreads=N has no meaning with the serial collector and should be removed.
info.parallel.gc.threads=The number of parallel garbage collection threads is set with -XX:ParallelGCThreads=N. Unless multiple JVMs and/or processes are collocated and competing for resources, it's generally best to remove this option and let the JVM determine an appropriate setting (JDK8) or manage it dynamically with ergonomics (JDK11+).
info.parallel.old.cruft=The option to enable/disable the parallel old collector, -XX:(+|-)UseParallelOldGC, is ignored/overriden and can be removed.
info.parallel.old.redundant=-XX:+UseParallelOldGC is redundant (enabled by default) and can be removed. The option is deprecated in JDK15 and removed in JDK16.
info.perf.data.disabled=Consider replacing -XX:-UsePerfData with -XX:+PerfDisableSharedMem. This will disable the writing of performance data to disk (/tmp/hsperfdata*) but still make it available via JMX.
info.perm.gen=A very old JDK with a permanent generation is being used. Perm gen space decommissioning began in JDK7 when interned strings and class static variables were moved to the Java heap, and symbols were moved to the native heap. In JDK8 the perm gen space was fully replaced by the metaspace, a native space holding only class metadata.
info.perm.size=There is an attempt to set the initial permanent generation size with -XX:PermSize. The permanent generation space was replaced by the metaspace in JDK8. The option is ignored and should be removed.
info.print.gc.application.concurrent.time=Remove -XX:+PrintGCApplicationConcurrentTime. It is redundant, as the same information can be calculated from the GC logging timestamps and durations. It adds overhead with no analysis value.
info.rmi.dgc.client.gcInterval.redundant=The sun.rmi.dgc.client.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
info.rmi.dgc.server.gcInterval.redundant=The sun.rmi.dgc.server.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
info.survivor.ratio.target=Target survivor ratio, the percentage of the survivor space allowed to be occupied, is set with -XX:TargetSurvivorRatio=N (e.g. -XX:TargetSurvivorRatio=90).
info.survivor.ratio=Survivor ratio, the size of the eden space compared to ONE survivor space, is set with -XX:SurvivorRatio=N (e.g. -XX:SurvivorRatio=6).
info.thread.priority.policy.redundant=-XX:ThreadPriorityPolicy=0 (default thread priorities) is redundant and can be removed.
info.tiered.compilation.disabled=Tiered compilation has been disabled with -XX:-TieredCompilation. Is this a small memory footprint use case? Or testing has show tiered compilation causes performance issues?
info.tiered.compilation.enabled=-XX:+TieredCompilation is redundant and can be removed, as tiered compilation is enabled by default in JDK8+.
info.trace.class.loading=The -XX:+TraceClassLoading option is enabled, causing class loading information to be output. This is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it.
info.trace.class.loading.disabled=-XX:-TraceClassLoading is redundant (disabled by default) and can be removed.
info.trace.class.unloading=The -XX:+TraceClassUnloading option is enabled, causing class unloading information to be output. This is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it.
info.trace.class.unloading.disabled=-XX:-TraceClassUnloading is redundant (disabled by default) and can be removed.
info.unaccounted.options.disabled=Unaccounted disabled JVM options: 
info.use.code.cache.flushing.disabled=Code cache flushing is disabled with -XX:-UseCodeCacheFlushing. The JIT compiler will stop compiling methods when the code cache is filled. Remove this option to allow the default flushing unless there is a valid use case (doubtful). 
info.use.thread.priorities.redundant=-XX:+UseThreadPriorities is redundant (the Java Thread API is enabled by default) and can be removed.
info.verbose.class=Class loading logging is enabled with -verbose:class. This is not a standard recommended logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less overhead.
warn.adaptive.size.policy.disabled=Adaptive size policy is disabled (-XX:-UseAdaptiveSizePolicy), and minimum heap size (-Xms, -XX:InitialHeapSize) and maximum heap size (-Xmx, -XX:MaxHeapSize) are not equal. The JVM will not be able to increase the heap beyond the minimum heap size. Remove -XX:-UseAdaptiveSizePolicy. Reference: https://access.redhat.com/solutions/5565311.
warn.biased.locking.disabled=Biased locking is disabled. Biased locking is a threading optimization that benefits objects that are only locked by a single thread. This is the typical use case, and it is enabled by default. Consider removing -XX:-UseBiasedLocking unless testing has shown that disabling biased locking improves performance.
warn.bytecode.back.comp.disabled=Bytecode background compilation is disabled. Remove -Xbatch or -XX:-BackgroundCompilation to compile bytecode in the background so threads do not block waiting but instead run in interpreter mode until the compilation is complete.
warn.bytecode.compile.disabled=Compilation to native code is disabled. Remove -Xint to allow the just in time (JIT) compiler to compile to native code for increased performance.
warn.bytecode.compile.first.invocation=Methods being compiled on first invocation. Remove -Xcomp to enabled the JVM to efficiently decide when to compile methods into bytecode.
warn.cgroup.memory.limit.override=An attempt to set the maximum heap size with -XX:+UseCGroupMemoryLimitForHeap is being overridden by -Xmx/-XX:MaxHeapSize. -XX:+UseCGroupMemoryLimitForHeap is an experimental option replaced by auto-detection of container limits in recent JDKs and removed altogether in JDK 11. See: https://bugs.openjdk.java.net/browse/JDK-8194086.
warn.cgroup.memory.limit=The maximum heap size is set with -XX:+UseCGroupMemoryLimitForHeap, an experimental option replaced by auto-detection of container limits in recent JDKs and removed altogether in JDK 11. See: https://bugs.openjdk.java.net/browse/JDK-8194086.
warn.check.jni.enabled=JNI validation checks are enabled with -Xcheck:jni. The options shouldbe removed when relevant testing/troubleshooting is completed, as it adds overhead and is not recommended for general production use.
warn.class.unloading.disabled=Class unloading is disabled with -XX:-ClassUnloading. Remove to allow the default unloading unreachable classes to collect metaspace.
warn.cms.class.unloading.disabled=CMS collection of metaspace is disabled with -XX:-CMSClassUnloadingEnabled. Remove to allow the default unloading unreachable classes to collect metaspace in the CMS concurrent cycle and avoid metaspace collections being done by a slow (single threaded) serial collector.
warn.cms.inc.mode.with.init.occup.fract=When the CMS collector is run in incremental mode, the CMS initiating occupancy fraction is ignored. Remove one of the following options: (1) -XX:+CMSIncrementalMode, (2) -XX:CMSInitiatingOccupancyFraction=<n>.
warn.cms.parallel.initial.mark.disabled=Multi-threaded CMS initial mark is disabled with -XX:-CMSParallelInitialMarkEnabled. Remove -XX:-CMSParallelInitialMarkEnabled and let the JVM determine the setting based on resources.
warn.cms.parallel.remark.disabled=Multi-threaded CMS remark is disabled with -XX:-CMSParallelRemarkEnabled. Remove -XX:-CMSParallelRemarkEnabled and let the JVM determine the setting based on resources.
warn.comp.class.disabled.heap.lt.32g=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.comp.class.disabled.heap.unk=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.comp.class.enabled.heap.gt.32g=Compressed class pointers are enabled with -XX:+UseCompressedClassPointers, and heap >= 32G. Compressed object references cannot be used on heaps >= 32G. Remove -XX-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.comp.class.size.heap.gt.32g=Compressed class pointers space size is set (-XX:CompressedClassSpaceSize), and heap >= 32G. Remove -XX:CompressedClassSpaceSize, as compressed object references should not be used on heaps >= 32G.
warn.comp.oops.disabled.heap.lt.32g=Compressed object references are disabled with -XX:-UseCompressedOops, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.comp.oops.disabled.heap.unk=Compressed object references are disabled with -XX:-UseCompressedOops. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.comp.oops.enabled.heap.gt.32g=Compressed object references are enabled with -XX:+UseCompressedOops, and heap >= 32G. Compressed object references should not be used on heaps >= 32G. Remove -XX:+UseCompressedOops and let the JVM determine the setting based on resources.
warn.concurrentio=Remove -Xconcurrentio, an old/undocumented/non-standard option that was removed in JDK 12 due to having no known use cases. It makes changes to JVM settings that are contrary to best practices with modern JVMs. Reference: https://bugs.openjdk.org/browse/JDK-8213767.
warn.container.perf.data.disk=If this is a container environment, it is recommended to disable the writing of performance data to disk (/tmp/hsperfdata*) with -XX:+PerfDisableSharedMem. Disk IOPS (Input/output Operations Per Second) is shared among containers. Eliminating disk access will prevent one workload monopolizing disk from impacting all containers.
warn.container.support.disabled=Container support is disabled with -XX:-UseContainerSupport, resulting in the JVM ignoring cgroup settings and determining cpu/cores from the host machine.
warn.diagnostic.debug.non.safepoints=Diagnostic non-safepoint debugging is enabled with -XX:+DebugNonSafepoints to improve JDK Flight Recorder (JFR) method profiling accuracy.
warn.diagnostic.guaranteed.safepoint.interval=Diagnostic guaranteed safepoint interval is set with -XX:GuaranteedSafepointInterval=N.
warn.diagnostic.print.safepoint.statistics=Diagnostic safepoint logging is enabled (e.g. -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 -XX:+LogVMOutput -XX:LogFile=/path/to/vm.log).
warn.diagnostic.unsyncload.class=Diagnostic parallel class loading is enabled with with -XX:+UnsyncloadClass. It is extremely unsafe. Reference: https://bugs.openjdk.java.net/browse/JDK-8140284.
warn.disable.attach.mechanism=jcmd, jmap, and jstack will not work because the creation of the AttachListener socket file (/tmp/.java_pid<pid>) used to communicate with the JVM is disabled with -XX:+DisableAttachMechanism.
warn.experimental.vm.options.enabled=Experimental options. Consider removing the following, as they are not recommended/supported in production: -XX:+UnlockExperimentalVMOptions
warn.explicit.gc.disabled.concurrent=Remove -XX:+ExplicitGCInvokesConcurrent since explicit garbage collection is disabled with -XX:+DisableExplicitGC.
warn.explicit.gc.disabled=Explicit garbage collection is disabled with -XX:+DisableExplicitGC. The JVM uses explicit garbage collection to manage direct memory (to free space when MaxDirectMemorySize is reached) and the Remote Method Invocation (RMI) system (to clean up unreachable remote objects). Disabling it for those use cases can cause a memory leak. Verify the application does not use direct memory (e.g. java.nio.DirectByteBuffer), does not make remote method calls or export remote objects like EJBs (everything runs in the same JVM), and does not depend on explicit garbage collection in some other way. Known applications that use direct memory: JBoss EAP7 (IO subsystem). If explicit garbage collection is required, remove -XX:+DisableExplicitGC, and if using the CMS or G1 collector, add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
warn.explicit.gc.not.concurrent=Consider adding -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently by the CMS and G1 collectors. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection altogether with -XX:+DisableExplicitGC. Reference: https://access.redhat.com/solutions/21994.
warn.fast.unordered.timestamps=Fast unordered timestamps are being explicitly enabled with -XX:+UnlockExperimentalVMOptions -XX:+UseFastUnorderedTimeStamps. This is known to cause logging issues on hardware that does not support invariant tsc (INVTSC) registers. Remove and let JVM ergonomics decide.
warn.g1.mixed.gc.live.thrshld.prcnt=The occupancy threshold for a region to be considered as a candidate region for a G1_CLEANUP collection is set with the -XX:G1MixedGCLiveThresholdPercent=N (default 65% JDK7/JDK8 < u40, 85% JDK8u40+). Consider removing this experimental option unless there is a valid use case (e.g. JDK8 < u40: https://bugs.openjdk.java.net/browse/JDK-8059452) and testing has shown it does not introduce any issues.
warn.heap.dump.on.oome.disabled=Remove -XX:-HeapDumpOnOutOfMemoryError and add -XX:+HeapDumpOnOutOfMemoryError instead (notice "+" vs. "-") for a heap dump to be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error.
warn.heap.dump.path.filename=A heap dump file name is specified with -XX:HeapDumpPath (e.g. -XX:HeapDumpPath=/mydir/heapdump.hprof). Heap dumps will not overwrite each other, so only an initial heap dump will be output. Subsequent heap dumps will fail due to the existing file. Unless disk space is a concern, configure to not lose data by specifying a directory (e.g. -XX:HeapDumpPath=/mydir/) and let the JVM use the default file name (which includes the process id). Reference: https://access.redhat.com/solutions/21109.
warn.jdk11.gc.log.file.overwrite=The gc log file has a static name and will be overwritten on JVM startup. Enable log file rotation and/or include a process or datestamp in the file name (e.g. -Xlog:gc*:file=gc_%p_%t.log:time,uptime:filecount=0,filesize=5M).
warn.jdk11.gc.log.file.rotation.disabled=GC log file rotation is disabled with filecount=0. Set filecount to a non-zero value or remove it (default 5) to enable GC log file rotation.
warn.jdk11.gc.log.file.size.0=Automatic GC log file rotation is disabled with filesize=0. Set filesize to a non-zero value or remove it (default 20M) to allow automatic log rotation.
warn.jdk11.gc.log.file.size.small=GC log file size (filesize=N[K|M|G]) is small (< 5M). Data needed for troubleshooting can be lost due to excessive log rotation. Consider increasing the size. 
warn.jdk8.g1.prior.u40=It is not recommended to use the G1 collector on JDK8 prior to update 40. Consider upgrading to the latest JDK.
warn.jdk8.g1.prior.u40.recs=JDK8 prior to update 40 the default values for G1HeapWastePercent (10) and G1MixedGCLiveThresholdPercent (65) are generally very bad. If upgrading to the latest JDK is not possible, consider setting more appropriate values: -XX:+UnlockExperimentalVMOptions -XX:G1MixedGCLiveThresholdPercent=85 -XX:G1HeapWastePercent=5.
warn.jdk8.gc.log.file.overwrite=The gc log file has a static name and will be overwritten on JVM startup. Enable log file rotation and/or include process id or datestamp in the file name (e.g. -Xloggc:gc_%p_%t.log).
warn.jdk8.gc.log.file.rotation.disabled.num=Number of GC log files is defined (-XX:NumberOfGCLogFiles), yet GC log file rotation is disabled. Either remove -XX:NumberOfGCLogFiles or enable GC log file rotation with -XX:+UseGCLogFileRotation.
warn.jdk8.gc.log.file.rotation.disabled=GC log file rotation is disabled (-XX:-UseGCLogFileRotation). Consider enabling rotation to protect disk space.
warn.jdk8.gc.log.file.rotation.not.enabled=Consider enabling gc log file rotation (-XX:+UseGCLogFileRotation -XX:GCLogFileSize=N[K|M|G] -XX:NumberOfGCLogFiles=N) to protect disk space.
warn.jdk8.gc.log.file.size.small=GC log file size (-XX:GCLogFileSize=N[K|M|G]) is small (< 5M). Data needed for troubleshooting can be lost due to excessive log rotation. Consider increasing the size.
warn.jdk8.print.gc.cause.disabled=Remove -XX:-PrintGCCause so trigger information critical for analysis will be output in gc logging (default behavior).
warn.jdk8.print.gc.details.disabled=PrintGCDetails is disabled. This is a standard recommended logging option that outputs details needed for GC analysis (e.g. generation, metaspace, and times data). Replace -XX:-PrintGCDetails with -XX:+PrintGCDetails. Or, if both -XX:-PrintGCDetails and -XX:+PrintGCDetails are set, remove -XX:-PrintGCDetails.
warn.jdk8.print.gc.details.missing=Add -XX:+PrintGCDetails, a standard recommended GC logging option that outputs details needed for GC analysis (e.g. generation, metaspace, and times data).
warn.jdk8.use.vm.interruptible.io=-XX:-UseVMInterruptibleIO is obsolete and should be removed. It is deprecated in JDK8 and removed in JDK11. 
warn.metaspace.lt.comp.class=MaxMetaspaceSize < CompressedClassSpaceSize, resulting in the JVM adjusting down the Class Metadata and Compressed Class Space sizes as follows: CompressedClassSpaceSize' = MaxMetaspaceSize - [2 * InitialBootClassLoaderMetaspaceSize]. Class Metadata Size' = MaxMetaspaceSize - CompressedClassSpaceSize'.
warn.omit.stack.trace.in.fast.throw.disabled=The -XX:-OmitStackTraceInFastThrow option is being used to enable stack traces in exception messages for the following exceptions: NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ArrayStoreException, ClassCastException. Disabled by default for performance reasons, as some JDK code uses exceptions for flow control. This can be useful troubleshooting issues, but may not be appropriate for production environments if many exceptions are thrown and many stack traces are logged.
warn.print.class.histogram.after.full.gc=The -XX:+PrintClassHistogramAfterFullGC option will cause a class histogram to be output after every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.print.class.histogram.before.full.gc=The -XX:+PrintClassHistogramBeforeFullGC option will cause a class histogram to be output before every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.print.class.histogram=The -XX:+PrintClassHistogram option will cause a class histogram to be output in the gc logging when a thread dump is taken. It is a heavyweight option that forces a full collection and can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.rmi.dgc.client.gcInterval.large=The sun.rmi.dgc.client.gcInterval value is large (> 24 hours). A typical value is at 1-4 hours (e.g. 4 hours: -Dsun.rmi.dgc.client.gcInterval=14400000). If Java Remote Method Invocation (Java RMI) is loaded and used, the interval may be too small and cause a memory leak, as Java RMI depends on regular collections to clean up unreachable objects. If Java RMI is not used, the option can be removed.
warn.rmi.dgc.client.gcInterval.small=The sun.rmi.dgc.client.gcInterval value is small (< 1 hour). A typical value is at least one hour (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000). If Java Remote Method Invocation (Java RMI) is loaded and used, this can cause excessive garbage collections.
warn.rmi.dgc.server.gcInterval.large=The sun.rmi.dgc.server.gcInterval value is large (> 24 hours). A typical value is at 1-4 hours (e.g. 4 hours: -Dsun.rmi.dgc.server.gcInterval=14400000). If Java Remote Method Invocation (Java RMI) is loaded and used, the interval may be too small and cause a memory leak, as Java RMI depends on regular collections to clean up unreachable objects. If Java RMI is not used, the option can be removed.
warn.rmi.dgc.server.gcInterval.small=The sun.rmi.dgc.server.gcInterval value is small (< 1 hour). A typical value is at least one hour (e.g. -Dsun.rmi.dgc.server.gcInterval=3600000). If Java Remote Method Invocation (Java RMI) is loaded and used, this can cause excessive garbage collections.
warn.rs=-Xrs prevents the JVM from handling signals. Issuing kill -3 or CTRL+Break will not work and will cause the Java processes to be terminated.
warn.tenuring.disabled=Tenuring is disabled with -XX:MaxTenuringThreshold=0 or by setting it to a value greater than 15 (e.g. -XX:MaxTenuringThreshold=32), resulting in objects surviving a young collection not being copied to a survivor space but being immediately promoted to the old generation. Unless testing has shown this makes sense for your application (e.g. mainly long live objects), consider removing this option to allow the default value to be applied.
warn.thread.priority.policy.aggressive=The aggressive Java Threads API policy is set with -XX:ThreadPriorityPolicy=1. It should be used with care, as it can cause performance degradation in the application and/or the entire system and requires root permission on Linux (or will be ignored).
warn.thread.priority.policy.aggressive.backdoor=The aggressive Java Threads API policy is set through a JDK8 back door (bug). Only -XX:ThreadPriorityPolicy=1 is checked for root permissions on Linux, which allows a non-root user to set the aggressive policy with a value other than "1" (e.g. -XX:ThreadPriorityPolicy=42). This will not port to JDK11+, which only allows values of "0" (normal) or "1" (aggressive). The aggressive policy should be used with care, as it can cause performance degradation in the application and/or the entire system.
warn.thread.priority.policy.bad=The thread priority policy setting (-XX:ThreadPriorityPolicy=N) is a bad value (e.g. a negative number) and being ignored. 
warn.thread.priority.policy.ignored=The thread priority policy setting (-XX:ThreadPriorityPolicy=N) is being ignored due to the Java Threads API being disabled with -XX:+UseThreadPriorities.
warn.thread.stack.size.not.set.32=Consider explicitly setting the thread stack size with the -Xss (n/a Solaris) or -XX:ThreadStackSize option, as the default size is typically much larger than needed, and 32-bit memory constraints generally require freeing unneeded thread stack memory to allow a larger heap.
warn.thread.stack.size.large=The thread stack size is on the large side (>= 1024k). Typical values are 128k (32-bit) or 256k (64-bit). If the JVM is 32-bit, consider testing to confirm a large thread stack size is needed. This is not an issue on 64-bit unless the unused memory results in physical memory exhaustion and swapping; however, 32-bit memory constraints generally require freeing unneeded thread stack memory to allow a larger heap.
warn.thread.stack.size.small=Thread stack size is less than 128K.
warn.thread.stack.size.tiny=Thread stack size is less than 1K. Were units (e.g. 'K') left off by mistake? 
warn.use.cond.card.mark=Conditional dirty card marking enabled with -XX:+UseCondCardMark. This is not a standard recommended option and can negatively impact performance (e.g. on single cpu/cores). Unless testing has shown this improves performance, consider removing this option.
warn.use.membar=The -XX:+UseMembar option is used. This was a workaround for a bug in old versions of JDK 1.6 (see https://bugs.openjdk.org/browse/JDK-6822370) and is not necessary with modern JVMs. If there is not a good use case for using this option, remove it, as it causes the JVM to use a memory barrier that slows down the JVM.
info.use.string.deduplication.redundant=-XX:-UseStringDeduplication is redundant (disabled by default) and can be removed.
info.use.string.deduplication.unsupported=-XX:(+|-)UseStringDeduplication is being ignored and can be removed (it applies only to G1 for 8u20 <= JDK <= 17).
warn.use.thread.priorities.disabled=The Java Thread API is disabled with -XX:+UseThreadPriorities.
warn.verify.none=Class verification during loading is disabled with -Xverify:none. This is unsupported and can result in corrupt or invalid classes being loaded, causing undetermined JVM behavior and crashes.